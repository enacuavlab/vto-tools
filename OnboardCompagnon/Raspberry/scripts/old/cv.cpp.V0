#include "cv.h"
#include <opencv2/opencv.hpp>
#include <pthread.h>

#define SCALE 3/2
#define CAMOUTSTR "/tmp/camera3"

using namespace cv;
using namespace std;


/*****************************************************************************/
struct pthreadarg_t {
  int width;
  int height;
  int mbx;
  int mby;
  int tabsize;
} pthreadarg_t;

struct motion_elt_t {
 int8_t x;
 int8_t y;
 uint16_t sad;
};
motion_elt_t *motionTabIn;

static pthread_mutex_t imv_mutex;
static pthread_cond_t imv_condv;
bool imv_ready=false;

static pthread_t img_thread;
static pthread_mutex_t img_mutex;
static pthread_cond_t img_condv;
bool img_ready=false;

bool init_ready=false;

Mat imageIn;
VideoWriter streamOut;

/*****************************************************************************/
void putpixel(int x,int y, Mat *img) 
{
  unsigned int k,m;

//      x=((i-1)*16)+24;
//      y=((j-1)*16)+24;

//      k=(y*mbx*16)+x;
//      param->data[k] = 0;

//      x=((i-1)*8)+12;
//      y=((j-1)*8)+12;

  // Y
//  k=(2*((y*mbx*16)+x));
  img->data[k] = 0;

  // U & V
//  k=(y*mbx*8)+x;
  m = (k & 1) ? 0xFF : 0x00;
//  img->data[uoffset+k] = img->data[uoffset+k] & m;
//  img->data[voffset+k] = img->data[voffset+k] & m;
}

/*****************************************************************************/
void bsline(int x,int y,int x2,int y2, Mat *img)
{
  int dx,dy,p;

  dx=x2-x;
  dy=y2-y;
  p = 2 * (dy) - (dx);
  while(x <= x2) {
    if(p < 0) {
      x=x+1;
      y=y;
      p = p + 2 * (dy);
    } else {
      x=x+1;
      y=y+1;
      p = p + 2 * (dy - dx);
    }
    putpixel(x,y,img);
  }
}

/*****************************************************************************/
void overlay(int mbx, int mby, unsigned int uoffset, unsigned int voffset, Mat *param, motion_elt_t *imv) 
{
  unsigned int i,j,k,l,m;
  int x,y;

  for (j = 0; j < mby; j++) {
    for (i = 0; i < mbx; i++) {

      // YUV420P
//      x=((i-1)*16)+24;
//      y=((j-1)*16)+24;

//      k=(y*mbx*16)+x;
//      param->data[k] = 0;

      x=((i-1)*8)+12;
      y=((j-1)*8)+12;

      // Y
      k=(2*((y*mbx*16)+x));
      param->data[k] = 0;

      // U & V
      k=(y*mbx*8)+x;
      m = (k & 1) ? 0xFF : 0x00;
      param->data[uoffset+k] = param->data[uoffset+k] & m;
      param->data[voffset+k] = param->data[voffset+k] & m;

      // ((width/16)+1, (height/16))
      motion_elt_t *p_vec = imv + (i+(mbx+1)*j);

      if (p_vec->x == 0 && p_vec->y == 0)
        continue;
//      if (p_vec->sad > sad_limit)
//	continue;

//      bsline(x,y,p_vec->x,p_vec->y,param);

    }
  }
}
//  cout << endl;

/*****************************************************************************/
static void *process_thread(void *ptr)
{
  struct pthreadarg_t args;
  memcpy(&args,ptr,sizeof(pthreadarg_t));

  unsigned int imageSize = ((args.width * args.height * sizeof(uint8_t))*SCALE);
  Mat imageOut(args.width, args.height, CV_8UC3,Scalar(0,0,0));

  unsigned int motionSize = (args.tabsize)*sizeof(motion_elt_t);
  motion_elt_t *motionTabOut = new motion_elt_t[args.tabsize];

  unsigned int uoffset=(args.width * args.height);
  unsigned int voffset=uoffset*5/4;

  while (true) {

    pthread_mutex_lock(&img_mutex);
    while (!img_ready) pthread_cond_wait(&img_condv, &img_mutex);
    memcpy(imageOut.data,imageIn.data,imageSize);		
    img_ready=false;
    pthread_mutex_unlock(&img_mutex);

    pthread_mutex_lock(&imv_mutex);
    while (!imv_ready) pthread_cond_wait(&imv_condv, &imv_mutex);
    memcpy(motionTabOut ,motionTabIn, motionSize);
    imv_ready=false;
    pthread_mutex_unlock(&imv_mutex);

    overlay(args.mbx,args.mby,uoffset,voffset,&imageOut,motionTabOut);
    streamOut.write(imageOut);
  }
  return((void *)0);
}


/*****************************************************************************/
void cv_init(int width, int height, int fps, int fmt)
{
  streamOut = VideoWriter(
    "appsrc ! "
    "shmsink socket-path=" CAMOUTSTR
    " wait-for-connection=false async=false sync=false",
    0,fps/1,Size(width,height),true);

  imageIn.create(width*SCALE, height, CV_8UC1);

  int mbx = width/16;
  int mby = height/16;
  int motionTabSize = (mbx+1) * mby;
  motionTabIn = new motion_elt_t[motionTabSize];

  pthread_mutex_init(&imv_mutex, NULL);
  pthread_cond_init(&imv_condv, NULL);

  pthread_mutex_init(&img_mutex, NULL);
  pthread_cond_init(&img_condv, NULL);

  struct pthreadarg_t param = {width,height,mbx,mby,motionTabSize};
  pthread_create(&img_thread, NULL, process_thread, (void *)&param);

  init_ready=true;
}


/*****************************************************************************/
void cv_process_img(uint8_t *p_buffer, int length, int64_t timestamp)
{
  if (init_ready) {
    pthread_mutex_lock(&img_mutex);
    memcpy(imageIn.data, p_buffer, length);		
    img_ready=true;
    pthread_cond_signal(&img_condv);
    pthread_mutex_unlock(&img_mutex);
  }
}


/*****************************************************************************/
void cv_process_imv(uint8_t *p_buffer, int length, int64_t timestamp)
{
  if (init_ready) {
    pthread_mutex_lock(&imv_mutex);
    memcpy(motionTabIn ,p_buffer, length);
    imv_ready=true;
    pthread_cond_signal(&imv_condv);
    pthread_mutex_unlock(&imv_mutex);
  }
}


/*****************************************************************************/
void cv_close(void)
{
}
